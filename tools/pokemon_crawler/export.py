"""
This module provides functions for exporting C code
based on the data that was obtained by the crawler
"""

from . import link
from . import evolutions
from . import normalize

def moveset_label_by_id(species_id, constants):
    """ Creates a moveset label based on the
    species id of a pokemon"""
    species = constants.species_table[species_id][8:].lower()
    return "moveset_pokemon_" + species

preamble = """/**
 * WARNING! This file is automatically generated! Do not modify! Instead change
 * data (or add if needed) to tools/pokemon_crawler/data.py.
 * Changes to this file will eventually be overwritten!

 **/
"""

def export_lvlup_array(lvlup_attacks, label):
    """ Exports a pokemon_move struct array that holds
    all levelup moves."""
    c = "pokemon_move " + label + "[] = {\n"
    for lvl, attack in lvlup_attacks:
        c += "\t{" + attack + ", " + str(lvl) + "},\n"
    c += "\t{0x1FF, 0x7F}\n};\n\n"
    return c

def export_lvlup_attacks(linked, outfile, constants):
    """ Exports the levelup attacks."""
    # First create a preamble
    output = preamble + """#include "types.h"
#include "pokemon.h"
#include "basestats.h"
#include "attack.h"\n\n"""

    # Create the moveset table
    table = "pokemon_move *pokemon_moves[POKEMON_CNT] = {\n"
    for i, _link in enumerate(linked):
        link_type, pkmn = _link
        if link_type == link.NULL:
            label = "NULL"
        elif link_type == link.LINKED:
            label = moveset_label_by_id(pkmn, constants)
        elif link_type == link.REAL:
            label = moveset_label_by_id(i, constants)
            # Dump the real moveset
            output += export_lvlup_array(pkmn.attacks_lvlup, label)
        else:
            raise Exception("Unkown link type" + link_type)
        table += "\t" + label + ",\n"
    table += "};\n"

    output += table
    
    # Output the file
    fp = open(outfile, "w+")
    fp.write(output)
    fp.close()


def export_egg_moves(linked, outfile, constants, rom, offset_evolution_table):
    """ Exports egg moves array. Finds basis stage
    pokemon by using knowledge of an evolution table
    of a pokemon rom."""
    # First get the prevolutions array
    prevolutions = evolutions.parse_evolutions(rom, offset_evolution_table, constants)
    # Create a preamble
    output = preamble + """#include "types.h"
#include "basestats.h"
#include "attack.h"\n\n
    """
    # Create the egg move list
    output += "u16 egg_moves[] = {\n"
    for i, _link in enumerate(linked):
        link_type, pkmn = _link
        if link_type == link.REAL and evolutions.is_basis_stage(prevolutions, i):
            if not len(pkmn.attacks_breed): continue
            output += "\t// " + constants.species_table[i][8:].capitalize() + "\n"
            output += "\t20000 + " + constants.species_table[i] + ", "
            for attack in pkmn.attacks_breed:
                output += attack + ", "
            output += "\n"
    output += "\t0xFFFF\n};\n"

    fp = open(outfile, "w+")
    fp.write(output)
    fp.close()

"""
# Define which tm/hm maps to which byte and bit
tm_map = {
    'Sonnentag': (1, 2),
    'Fassade': (5, 1),
    'Matschbombe': (4, 3),
    'Schutzschild': (2, 0),
    'Regentanz': (2, 1),
    'Donner': (3, 0),
    'Folterknecht': (5, 0),
    'Stahlflü1gel': (5, 6),
    'Gedankengut': (0, 3),
    'Toxin': (0, 5),
    'Frustration': (2, 4),
    'Schockwelle': (4, 1),
    'Rückkehr': (3, 2),
    'Aquawelle': (0, 2),
    'Verhöhner': (1, 3),
    'Doppelteam': (3, 7),
    'Hagelsturm': (0, 6),
    'Reflektor': (4, 0),
    'Kraftreserve': (1, 1),
    'Gigasauger': (2, 2),
    'Lichtschild': (1, 7),
    'Sandsturm': (4, 4),
    'Raub': (5, 5),
    'Flammenwurf': (4, 2),
    'Spukball': (3, 5),
    'Wertewechsel': (5, 7),
    'Bodyguard': (2, 3),
    'Aero-Ass': (4, 7),
    'Erholung': (5, 3),
    'Eisenschweif': (2, 6),
    'Protzer': (0, 7),
    'Kugelsaat': (1, 0),
    'Psychokinese': (3, 4),
    'Felsgrab': (4, 6),
    'Hitzekoller': (6, 1),
    'Drachenklaue': (0, 1),
    'Brüller': (0, 4),
    'Blizzard': (1, 5),
    'Hyperstrahl': (1, 6),
    'Eisstrahl': (1, 4),
    'Power-Punch': (0, 0),
    'Donnerblitz': (2, 7),
    'Solarstrahl': (2, 5),
    'Übernahme': (6, 0),
    'Feuersturm': (4, 5),
    'Geheimpower': (5, 2),
    'Durchbruch': (3, 6),
    'Erdbeben': (3, 1),
    'Schaufler': (3, 3),
    'Anziehung': (5, 4),
    'Zerschneider' : (6, 2),
    'Fliegen' : (6, 3),
    'Surfer' : (6, 4),
    'Stärke' : (6, 5),
    'Blitz' : (6, 6),
    'Zertrümmerer' : (6, 7),
    'Kaskade' : (7, 0),
    'Taucher' : (7, 1)
}
"""

def export_tm_struct(attacks_tm):
    """ Exports a c struct initialization for
    that holds the bitfields for the tm/hm
    compatibility."""
    stru = "\t{\n"
    # Assign each tm to its proper byte
    bytes = [[] for i in range(8)]
    for type, num, attack in attacks_tm:
       normalized_tm = type.upper() + str(num).zfill(2) + "_" + attack[7:]
       if type == "vm": num += 50
       byte = num >> 3
       bytes[byte].append(normalized_tm)
    
    # Parse each byte
    for i in range(len(bytes)):
        byte = bytes[i]
        if not len(byte):
            stru += "\t\t0,\n"
        else:
            stru += "\t\t" + " | ".join(byte) + ",\n"

    return stru + "\t},\n"

def export_tm_move_compatibility(linked, outfile, constants):
    """ Exports a c array of tm/hm compatibilities
    based on linked pkmn data."""
    # Create a preamble
    output = preamble + '#include "types.h"\n#include "pokemon.h"\n\n'

    # Create the compatibility array (8 bytes for each pkmn)
    output += "u8 pokemon_tm_compatibility[POKEMON_CNT][8] = {\n"
    for i, _link in enumerate(linked):
        output += "\t// " + constants.species_table[i][8:].capitalize() + "\n"
        link_type, pkmn = _link
        if link_type == link.LINKED:
            # Unlink
            i = pkmn
            link_type, pkmn = linked[i]
        if link_type == link.NULL:
            # No tms compatible
            output += export_tm_struct([])
        elif link_type == link.REAL:
            output += export_tm_struct(pkmn.attacks_tm)
        else:
            raise Exception("Unkown link type " + str(link_type))

    output += "};\n"

    #Output the file
    fp = open(outfile, "w+")
    fp.write(output)
    fp.close()

def export_move_tutor_struct(attacks_tutor):
    """ Exports a c struct initialization that
    describes the move tutor compatbility
    for a given dict."""
    if not len(attacks_tutor): return "\t0,\n"
    stru = "\t" + " | ".join([
        "MOVE_TUTOR_" + attacks_tutor[i][7:] for i in attacks_tutor
    ])
    return stru + ",\n"

def export_move_tutor_compatibility(linked, outfile, constants):
    """ Exports a c array of move tutor compatibilities
    based on linked pkmn data."""
    # Create a preamble
    output = preamble + '#include "types.h"\n#include "pokemon.h"\n#include "move_tutor.h"\n\n'

    # Create the compatibility array (8 bytes for each pkmn)
    output += "u32 pokemon_tutor_compatibility[POKEMON_CNT] = {\n"
    for i, _link in enumerate(linked):
        output += "\t// " + constants.species_table[i][8:].capitalize() + "\n"
        link_type, pkmn = _link
        if link_type == link.LINKED:
            # Unlink
            i = pkmn
            link_type, pkmn = linked[i]
        if link_type == link.NULL:
            # No tms compatible
            output += export_move_tutor_struct({})
        elif link_type == link.REAL:
            output += export_move_tutor_struct(pkmn.attacks_tutor)
        else:
            raise Exception("Unkown link type " + str(link_type))

    output += "};\n"

    #Output the file
    fp = open(outfile, "w+")
    fp.write(output)
    fp.close()

def inaccessible_set_label_by_id(species_id, constants):
    """ Creates a inaccessible set label based on the
    species id of a pokemon"""
    species = constants.species_table[species_id][8:].lower()
    return "inaccessible_moves_pokemon_" + species

def export_inaccessible_array(inaccessebile_attacks, label):
    """ Exports a list of moves terminated by 0xFFFF
    and identified by a given label."""
    c = "u16 " + label + "[] = {\n"
    c += "\t"
    for attack in inaccessebile_attacks:
        c += attack + ", "
    c += "0xFFFF\n"
    c += "};\n"
    return c

def export_inaccessible_attacks(linked, outfile, constants):
    """ Exports the inaccessible attacks, i.e. attacks
    that are not availible by common methods. Those might
    be used by some feature I guess and thus will also be
    exported."""
    # First create a preamble
    output = preamble + """#include "types.h"
#include "pokemon.h"
#include "basestats.h"
#include "attack.h"\n\n"""

    # Create the moveset table
    table = "u16 *pokemon_inaccessible_moves[POKEMON_CNT] = {\n"
    for i, _link in enumerate(linked):
        link_type, pkmn = _link
        if link_type == link.NULL:
            label = "NULL"
        elif link_type == link.LINKED:
            label = inaccessible_set_label_by_id(pkmn, constants)
        elif link_type == link.REAL:
            label = inaccessible_set_label_by_id(i, constants)
            # Dump the real moveset
            output += export_inaccessible_array(pkmn.inaccessible_attacks(constants), label)
        else:
            raise Exception("Unkown link type" + link_type)
        table += "\t" + label + ",\n"
    table += "};\n"

    output += table
    
    # Output the file
    fp = open(outfile, "w+")
    fp.write(output)
    fp.close()
