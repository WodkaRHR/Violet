"""
This module provides functions for exporting C code
based on the data that was obtained by the crawler
"""

from . import link
from . import evolutions
from . import normalize

def species_name_by_idx(species, constants):
    """ Creates a readable species name based on its idx. This is
    used for generating meaningfull comments.
    
    Parameters:
    -----------
    species : int
        The desired species
    constants: pymap.constants.Constants
        The constant tables.
    
    Return:
    -------
    name : str
        The readable name of the species
    """
    for name in constants['species']:
        if constants['species'][name] == species:
            return name
    raise RuntimeError(f'Unassignable species {species}')
    

def moveset_label_by_id(species_id, constants):
    """ Creates a moveset label based on the
    species id of a pokemon"""
    species = species_name_by_idx(species_id, constants)[8:].lower()
    return "moveset_pokemon_" + species

preamble = """/**
 * WARNING! This file is automatically generated! Do not modify! Instead change
 * data (or add if needed) to tools/pokemon_crawler/data.py.
 * Changes to this file will eventually be overwritten!

 **/
"""

def export_lvlup_array(lvlup_attacks, label):
    """ Exports a pokemon_move struct array that holds
    all levelup moves."""
    c = "pokemon_move " + label + "[] = {\n"
    for lvl, attack in lvlup_attacks:
        c += "\t{" + attack + ", " + str(lvl) + "},\n"
    c += "\t{0x1FF, 0x7F}\n};\n\n"
    return c

def export_lvlup_attacks(linked, symbol, constants):
    """ Exports the levelup attacks."""
    # First create a preamble
    output = ""

    # Create the moveset table
    table = "pokemon_move *" + symbol + "[POKEMON_CNT] = {\n"
    for i, _link in enumerate(linked):
        link_type, pkmn = _link
        if link_type == link.NULL:
            label = "NULL"
        elif link_type == link.LINKED:
            label = moveset_label_by_id(pkmn, constants)
        elif link_type == link.REAL:
            label = moveset_label_by_id(i, constants)
            # Dump the real moveset
            output += export_lvlup_array(pkmn.attacks_lvlup, label)
        else:
            raise Exception("Unkown link type" + link_type)
        table += "\t" + label + ",\n"
    table += "};\n"
    return output + "\n" + table

def export_egg_moves(linked, symbol, constants, 
    elf, elf_text_dump, elf_evolution_table_dump, evolution_table_symbol):
    """ Exports egg moves array. Finds basis stage
    pokemon by using knowledge of an evolution table
    of a pokemon rom."""
    # First get the prevolutions array
    prevolutions = evolutions.prevolutions_from_elf(elf, elf_text_dump, 
    elf_evolution_table_dump, evolution_table_symbol, constants)
    # Create the egg move list
    output = "u16 " + symbol + "[] = {\n"
    for i, _link in enumerate(linked):
        link_type, pkmn = _link
        if link_type == link.REAL and evolutions.is_basis_stage(prevolutions, i):
            if not len(pkmn.attacks_breed): continue
            output += "\t// " + species_name_by_idx(i, constants)[8:].capitalize() + "\n"
            output += "\t20000 + " + species_name_by_idx(i, constants) + ", "
            for attack in pkmn.attacks_breed:
                output += attack + ", "
            output += "\n"
    output += "\t0xFFFF\n};\n"
    return output

"""
# Define which tm/hm maps to which byte and bit
tm_map = {
    'Sonnentag': (1, 2),
    'Fassade': (5, 1),
    'Matschbombe': (4, 3),
    'Schutzschild': (2, 0),
    'Regentanz': (2, 1),
    'Donner': (3, 0),
    'Folterknecht': (5, 0),
    'Stahlflü1gel': (5, 6),
    'Gedankengut': (0, 3),
    'Toxin': (0, 5),
    'Frustration': (2, 4),
    'Schockwelle': (4, 1),
    'Rückkehr': (3, 2),
    'Aquawelle': (0, 2),
    'Verhöhner': (1, 3),
    'Doppelteam': (3, 7),
    'Hagelsturm': (0, 6),
    'Reflektor': (4, 0),
    'Kraftreserve': (1, 1),
    'Gigasauger': (2, 2),
    'Lichtschild': (1, 7),
    'Sandsturm': (4, 4),
    'Raub': (5, 5),
    'Flammenwurf': (4, 2),
    'Spukball': (3, 5),
    'Wertewechsel': (5, 7),
    'Bodyguard': (2, 3),
    'Aero-Ass': (4, 7),
    'Erholung': (5, 3),
    'Eisenschweif': (2, 6),
    'Protzer': (0, 7),
    'Kugelsaat': (1, 0),
    'Psychokinese': (3, 4),
    'Felsgrab': (4, 6),
    'Hitzekoller': (6, 1),
    'Drachenklaue': (0, 1),
    'Brüller': (0, 4),
    'Blizzard': (1, 5),
    'Hyperstrahl': (1, 6),
    'Eisstrahl': (1, 4),
    'Power-Punch': (0, 0),
    'Donnerblitz': (2, 7),
    'Solarstrahl': (2, 5),
    'Übernahme': (6, 0),
    'Feuersturm': (4, 5),
    'Geheimpower': (5, 2),
    'Durchbruch': (3, 6),
    'Erdbeben': (3, 1),
    'Schaufler': (3, 3),
    'Anziehung': (5, 4),
    'Zerschneider' : (6, 2),
    'Fliegen' : (6, 3),
    'Surfer' : (6, 4),
    'Stärke' : (6, 5),
    'Blitz' : (6, 6),
    'Zertrümmerer' : (6, 7),
    'Kaskade' : (7, 0),
    'Taucher' : (7, 1)
}
"""

def export_tm_struct(attacks_tm):
    """ Exports a c struct initialization for
    that holds the bitfields for the tm/hm
    compatibility."""
    stru = "\t{\n"
    # Assign each tm to its proper byte
    bytes = [0 for i in range(8)]
    for type, num, attack in attacks_tm:
       # normalized_tm = type.upper() + str(num).zfill(2) + "_" + attack[7:]
       if type == "vm": num += 50
       idx = num - 1
       byte = idx >> 3
       bit = idx & 7
       bytes[byte] |= 2 ** bit

    
    # Parse each byte
    for i in range(len(bytes)):
        byte = bytes[i]
        stru += "\t\t" + hex(byte) + ",\n"

    return stru + "\t},\n"

def export_tm_move_compatibility(linked, symbol, constants):
    """ Exports a c array of tm/hm compatibilities
    based on linked pkmn data."""
    # Create a preamble
    output = ""

    # Create the compatibility array (8 bytes for each pkmn)
    output += "u8 " + symbol + "[POKEMON_CNT][8] = {\n"
    for i, _link in enumerate(linked):
        output += "\t// " + species_name_by_idx(i, constants)[8:].capitalize() + "\n"
        link_type, pkmn = _link
        if link_type == link.LINKED:
            # Unlink
            i = pkmn
            link_type, pkmn = linked[i]
        if link_type == link.NULL:
            # No tms compatible
            output += export_tm_struct([])
        elif link_type == link.REAL:
            output += export_tm_struct(pkmn.attacks_tm)
        else:
            raise Exception("Unkown link type " + str(link_type))

    output += "};\n"
    return output

def export_move_tutor_struct(attacks_tutor):
    """ Exports a c struct initialization that
    describes the move tutor compatbility
    for a given dict."""
    if not len(attacks_tutor): return "\t0,\n"
    stru = "\t" + " | ".join([
        "(1 << MOVE_TUTOR_" + attacks_tutor[i][7:] + ")" for i in attacks_tutor
    ])
    return stru + ",\n"

def export_move_tutor_compatibility(linked, symbol, constants):
    """ Exports a c array of move tutor compatibilities
    based on linked pkmn data."""

    # Create the compatibility array (8 bytes for each pkmn)
    output = "u32 " + symbol + "[POKEMON_CNT] = {\n"
    for i, _link in enumerate(linked):
        output += "\t// " + species_name_by_idx(i, constants)[8:].capitalize() + "\n"
        link_type, pkmn = _link
        if link_type == link.LINKED:
            # Unlink
            i = pkmn
            link_type, pkmn = linked[i]
        if link_type == link.NULL:
            # No tms compatible
            output += export_move_tutor_struct({})
        elif link_type == link.REAL:
            output += export_move_tutor_struct(pkmn.attacks_tutor)
        else:
            raise Exception("Unkown link type " + str(link_type))

    output += "};\n"
    return output

def inaccessible_set_label_by_id(species_id, constants):
    """ Creates a inaccessible set label based on the
    species id of a pokemon"""
    species = species_name_by_idx(species_id, constants)[8:].lower()
    return "inaccessible_moves_pokemon_" + species

def export_inaccessible_array(inaccessebile_attacks, label):
    """ Exports a list of moves terminated by 0xFFFF
    and identified by a given label."""
    c = "u16 " + label + "[] = {\n"
    c += "\t"
    for attack in inaccessebile_attacks:
        c += attack + ", "
    c += "0xFFFF\n"
    c += "};\n"
    return c

def export_inaccessible_attacks(linked, symbol, constants):
    """ Exports the inaccessible attacks, i.e. attacks
    that are not availible by common methods. Those might
    be used by some feature I guess and thus will also be
    exported."""

    output = ""
    # Create the moveset table
    table = "u16 *" + symbol + "[POKEMON_CNT] = {\n"
    for i, _link in enumerate(linked):
        link_type, pkmn = _link
        if link_type == link.NULL:
            label = "NULL"
        elif link_type == link.LINKED:
            label = inaccessible_set_label_by_id(pkmn, constants)
        elif link_type == link.REAL:
            label = inaccessible_set_label_by_id(i, constants)
            # Dump the real moveset
            output += export_inaccessible_array(pkmn.inaccessible_attacks(constants), label)
        else:
            raise Exception("Unkown link type" + link_type)
        table += "\t" + label + ",\n"
    table += "};\n"
    return output + "\n" + table
